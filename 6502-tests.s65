; 

;-------------------------------------------------------------------------

                .include "./submodules/beeb/include/beeb.s65"
                
;-------------------------------------------------------------------------

State: .struct
a:
                .fill 1
x:
                .fill 1
y:
                .fill 1
s:
                .fill 1
p:
                .fill 1
operand:
                .fill 1
                .endstruct

Test: .macro exec,index,simulate,next,name
                .word \exec
                .byte \index
                .word \simulate
                .word \next
                .shiftl \name
                .endmacro
                
;-------------------------------------------------------------------------

Index: .block
none=0
x=1
y=2
                .endblock
                
P: .block
N=$80
V=$40
U=$20
B=$10
D=$08
I=$04
Z=$02
C=$01
                .endblock

simulate_p: .macro mask
                .if \mask==0
                lda input_state.p
                sta simulated_state.p
                .elsif \mask==255
                php
                pla
                sta simulated_state.p
                .else
                php
                lda input_state.p
                and #(\mask)^$ff
                sta simulated_state.p
                pla
                and #\mask
                ora simulated_state.p
                sta simulated_state.p
                .endif
                .endmacro

simulate_s: .macro
                lda input_state.s
                sta simulated_state.s
                .endmacro
                
simulate_y: .macro
                lda input_state.y
                sta simulated_state.y
                .endmacro
                
simulate_x: .macro
                lda input_state.x
                sta simulated_state.x
                .endmacro

simulate_a: .macro
                lda input_state.a
                sta simulated_state.a
                .endmacro

simulate_operand: .macro
                lda input_state.operand
                sta simulated_state.operand
                .endmacro
                
;-------------------------------------------------------------------------

*=0
                .dsection zp_bss
                .cerror *>$90,'zp overflow'

                ; start high to accommodate *SPOOL + ADFS
*=$2000
                .dsection code
                .cerror *>$7c00,'code overflow'
                
;-------------------------------------------------------------------------

                .section zp_bss
                ; input for instruction
input_state: .dstruct State

                ; result of executing the instruction.
                ; output_state.operand is pre-filled with
                ; input_state.operand, to accommodate read
                ; instructions.
output_state: .dstruct State

                ; result of simulating the instruction.
                ; simulated_state.operand is not initialized.
simulated_state: .dstruct State

                ; always points to output_state.operand.
output_operand_ptr: .fill 2
print_ptr: .fill 2
old_language_rom: .fill 1
test_ptr: .fill 2
any_bad: .fill 1
exec_routine: .fill 2
index_type: .fill 1

                ; when bit 7 set, show fancy(ish) progress display.
                ; Inhibited when *SPOOLing.
show_progress: .fill 1
                .endsection zp_bss

;-------------------------------------------------------------------------

                .section code

                sta $fffe
                
                .cpu '65c02'
                ldx #$ff
                phx             ;1-byte NOP on NMOS
                inx
                plx             ;1-byte NOP on NMOS
                beq +
                brk
                .text 255,'Requires NMOS 6502',0
+
                .cpu 'default'

                lda #$80
                sta show_progress
                
                lda #199        ;read *SPOOL file handle (AUG p204)
                jsr osbyte_x00_yff
                cpx #0
                beq +
                asl show_progress
+

                lda #252        ;current language ROM (AUG p243)
                jsr osbyte_x00_yff
                stx old_language_rom

                lda #<tests
                sta test_ptr+0
                lda #>tests
                sta test_ptr+1

run_instruction_test_loop:
                ldy #0
                lda (test_ptr),y
                iny
                ora (test_ptr),y
                beq all_tests_done

                ldy #0

                ; fix up exec routine
                lda (test_ptr),y
                iny
                sta jmp_exec+1
                sta exec_routine+0
                
                lda (test_ptr),y
                iny
                sta jmp_exec+2
                sta exec_routine+1

                lda (test_ptr),y
                iny
                sta index_type

                ; fix up simulate routine
                lda (test_ptr),y
                iny
                sta jsr_simulate+1
                
                lda (test_ptr),y
                iny
                sta jsr_simulate+2

                ; fix up next_state routine
                lda (test_ptr),y
                iny
                sta jmp_next_state+1

                lda (test_ptr),y
                iny
                sta jmp_next_state+2

                ; print name
-
                lda (test_ptr),y
                iny
                lsr a
                php
                jsr oswrch
                plp
                bcc -

                clc
                tya
                adc test_ptr+0
                sta test_ptr+0
                bcc +
                inc test_ptr+1
+

                ; initialise output_operand_ptr
                lda #<output_state.operand
                sta output_operand_ptr+0
                lda #>output_state.operand
                sta output_operand_ptr+1

                ; initialise state
                lda #0
                sta any_bad
                sta input_state.operand
                sta input_state.a
                sta input_state.x
                sta input_state.y
                php
                pla
                sta input_state.p
                
                lda #$ff
                sta input_state.s

test_one_state_loop:
                lda input_state.operand
                sta output_state.operand
                
                ldx input_state.s
                txs
                lda input_state.p
                pha
                ldy input_state.y
                ldx input_state.x
                lda input_state.a
                plp
jmp_exec:
                jmp jmp_exec
exec_done:
                php
                sta output_state.a
                stx output_state.x
                sty output_state.y
                pla
                sta output_state.p
                tsx
                stx output_state.s

                ldx #$ff
                txs

                cld
                cli

jsr_simulate:
                jsr jsr_simulate

                lda simulated_state.a
                cmp output_state.a
                bne bad

                lda simulated_state.x
                cmp output_state.x
                bne bad

                lda simulated_state.y
                cmp output_state.y
                bne bad

                lda simulated_state.p
                cmp output_state.p
                bne bad

                lda simulated_state.s
                cmp output_state.s
                bne bad

                lda simulated_state.operand
                cmp output_state.operand
                bne bad

jmp_next_state:
                jmp jmp_next_state

bad:
                bit any_bad
                bmi +
                jsr osnewl
+
                lda #$80
                sta any_bad
                jsr print_states
                jmp jmp_next_state
                ; ...

instruction_test_done:
                sta $ffff

                bit any_bad
                bmi +

                jsr print0
                .text " - ok",10,13,0
+

                jmp run_instruction_test_loop

all_tests_done:                
                lda #142        ;enter language ROM (AUG p166)
                ldx old_language_rom
                jmp osbyte

;-------------------------------------------------------------------------

noise_a:
                clc
                lda input_state.a
                adc #11
                sta input_state.a
                rts
                
noise_x:
                lda index_type
                cmp #Index.x
                beq +
                clc
                lda input_state.x
                adc #13
                sta input_state.x
+
                rts

noise_y:
                lda index_type
                cmp #Index.y
                beq +
                clc
                lda input_state.y
                adc #17
                sta input_state.y
+
                rts                

noise_s:
                clc
                lda input_state.s
                adc #19
                sta input_state.s
                rts

                ; cycles through all operands  
cycle_operand:
                jsr noise_a
                jsr noise_x
                jsr noise_y
                jsr noise_s
                
                inc input_state.operand
                bne test_one_state_loop
                jmp instruction_test_done

                ; cycles through all operand, A, C. When operand
                ; changes, overwrites the immediate value in the exec
                ; routine with it.
cycle_imm_A_C:
                inc input_state.a
                bne test_one_state_loop
                
                jsr next_operand_C

                lda input_state.operand
                ldy #1
                sta (exec_routine),y
                jmp test_one_state_loop

                ; cycles through all operand, A, C.
cycle_operand_A_C:
                inc input_state.a
                bne test_one_state_loop
                
                jsr next_operand_C
                jmp test_one_state_loop

                ; select next operand, C. If operand changed, return
                ; to caller; otherwise, loop or done.
next_operand_C:
                lda input_state.p
                eor #1
                sta input_state.p
                lsr a
                bcs test_one_state_loop

                jsr noise_x
                jsr noise_y
                jsr noise_s

                lda input_state.operand
                eor #$ff
                jsr progress

                inc input_state.operand
                beq instruction_test_done
                rts

cycle_operand_S:
                inc input_state.operand
                bne test_one_state_loop

                ; slight pain, as S starts at $ff. Well, at least the
                ; progress printing is easy.
                lda input_state.s
                jsr progress

                ldx input_state.s
                dex
                stx input_state.s
                cpx #$ff
                bne test_one_state_loop

                jmp instruction_test_done

;-------------------------------------------------------------------------

progress: .proc
                bit $ff
                bmi all_tests_done

                bit show_progress
                bpl done
                
                pha
                lda #' '
                jsr oswrch
                pla
                jsr print_hex
                lda #8
                jsr oswrch
                jsr oswrch
                jsr oswrch
done:
                rts
                .endproc
                
;-------------------------------------------------------------------------

tests:
                .Test exec_lax_zpg,Index.none,simulate_lax,cycle_operand,"lax $nn"
                .Test exec_lax_zpy,Index.y,simulate_lax,cycle_operand,"lax $nn,y"
                .Test exec_lax_abs,Index.none,simulate_lax,cycle_operand,"lax $nnnn"
                .Test exec_lax_aby,Index.y,simulate_lax,cycle_operand,"lax $nnnn,y"
                .Test exec_lax_inx,Index.x,simulate_lax,cycle_operand,"lax ($nn,x)"
                .Test exec_lax_iny,Index.y,simulate_lax,cycle_operand,"lax ($nn),y"
                
                .Test exec_asr_imm,Index.none,simulate_asr,cycle_imm_A_C,"asr #$nn"
                
                .Test exec_anc_imm,Index.none,simulate_anc,cycle_imm_A_C,"anc #$nn"
                .Test exec_anc2_imm,Index.none,simulate_anc,cycle_imm_A_C,"anc2 #$nn"

                .Test exec_dcp_zpg,Index.none,simulate_dcp,cycle_operand_A_C,"dcp $nn"
                .Test exec_dcp_zpx,Index.x,simulate_dcp,cycle_operand_A_C,"dcp $nn,x"
                .Test exec_dcp_abs,Index.none,simulate_dcp,cycle_operand_A_C,"dcp $nnnn"
                .Test exec_dcp_abx,Index.x,simulate_dcp,cycle_operand_A_C,"dcp $nnnn,x"
                .Test exec_dcp_aby,Index.y,simulate_dcp,cycle_operand_A_C,"dcp $nnnn,y"
                .Test exec_dcp_inx,Index.x,simulate_dcp,cycle_operand_A_C,"dcp ($nn,x)"
                .Test exec_dcp_iny,Index.y,simulate_dcp,cycle_operand_A_C,"dcp ($nn),y"

                .Test exec_isb_zpg,Index.none,simulate_isb,cycle_operand_A_C,"isb $nn"
                .Test exec_isb_zpx,Index.x,simulate_isb,cycle_operand_A_C,"isb $nn,x"
                .Test exec_isb_abs,Index.none,simulate_isb,cycle_operand_A_C,"isb $nnnn"
                .Test exec_isb_abx,Index.x,simulate_isb,cycle_operand_A_C,"isb $nnnn,x"
                .Test exec_isb_aby,Index.y,simulate_isb,cycle_operand_A_C,"isb $nnnn,y"
                .Test exec_isb_inx,Index.x,simulate_isb,cycle_operand_A_C,"isb ($nn,x)"
                .Test exec_isb_iny,Index.y,simulate_isb,cycle_operand_A_C,"isb ($nn),y"

                .Test exec_lds_aby,Index.y,simulate_lds,cycle_operand_S,"lds $nnnn,y"

                .word 0

;-------------------------------------------------------------------------

exec_lax_zpg: .block
                lax output_state.operand
                jmp exec_done
                .endblock

exec_lax_zpy: .block
                lax output_state.operand,y
                jmp exec_done
                .endblock

exec_lax_abs: .block
                lax @w output_state.operand
                jmp exec_done
                .endblock

exec_lax_aby: .block
                lax @w output_state.operand,y
                jmp exec_done
                .endblock

exec_lax_inx: .block
                lax (output_operand_ptr,x)
                jmp exec_done
                .endblock

exec_lax_iny: .block
                lax (output_operand_ptr),y
                jmp exec_done
                .endblock

simulate_lax:
                lda input_state.operand
                sta simulated_state.a
                sta simulated_state.x
                .simulate_p P.N|P.Z
                .simulate_y
                .simulate_s
                .simulate_operand
                rts

;-------------------------------------------------------------------------

exec_asr_imm: .block
                asr #0
                jmp exec_done
                .endblock

simulate_asr:
                lda input_state.a
                and input_state.operand
                lsr a
                sta simulated_state.a
                
                .simulate_p P.N|P.Z|P.C

                ; lsr simulated_state.a

                ; lda simulated_state.p
                ; adc #0
                ; sta simulated_state.p

                .simulate_x
                .simulate_y
                .simulate_s
                .simulate_operand
                rts

;-------------------------------------------------------------------------

exec_anc_imm: .block
                anc #0
                jmp exec_done
                .endblock

exec_anc2_imm: .block
                .byte $2b,$00
                jmp exec_done
                .endblock

simulate_anc:
                lda input_state.a
                and input_state.operand
                sta simulated_state.a

                cmp #$80
                and #$ff
                .simulate_p P.N|P.Z|P.C

                .simulate_x
                .simulate_y
                .simulate_s
                .simulate_operand
                rts

;-------------------------------------------------------------------------

exec_dcp_zpg:
                dcp output_state.operand
                jmp exec_done

exec_dcp_zpx:
                dcp output_state.operand,x
                jmp exec_done

exec_dcp_abs:
                dcp @w output_state.operand
                jmp exec_done

exec_dcp_abx:
                dcp @w output_state.operand,x
                jmp exec_done

exec_dcp_aby:
                dcp @w output_state.operand,y
                jmp exec_done

exec_dcp_inx:
                dcp (output_operand_ptr,x)
                jmp exec_done

exec_dcp_iny:
                dcp (output_operand_ptr),y
                jmp exec_done

simulate_dcp:
                ldx input_state.operand
                dex
                stx simulated_state.operand
                lda input_state.a
                cmp simulated_state.operand
                .simulate_p P.N|P.Z|P.C

                .simulate_a
                .simulate_x
                .simulate_y
                .simulate_s
                rts

;-------------------------------------------------------------------------

exec_isb_zpg:
                isb output_state.operand
                jmp exec_done

exec_isb_zpx:
                isb output_state.operand,x
                jmp exec_done

exec_isb_abs:
                isb @w output_state.operand
                jmp exec_done

exec_isb_abx:
                isb @w output_state.operand,x
                jmp exec_done

exec_isb_aby:
                isb @w output_state.operand,y
                jmp exec_done

exec_isb_inx:
                isb (output_operand_ptr,x)
                jmp exec_done

exec_isb_iny:
                isb (output_operand_ptr),y
                jmp exec_done

simulate_isb:
                ldx input_state.operand
                inx
                stx simulated_state.operand
                lda input_state.p
                lsr a
                lda input_state.a
                sbc simulated_state.operand
                sta simulated_state.a
                .simulate_p P.N|P.V|P.Z|P.C

                .simulate_x
                .simulate_y
                .simulate_s
                rts

;-------------------------------------------------------------------------

exec_lds_aby:
                lds output_state.operand,y
                jmp exec_done

simulate_lds:
                lda input_state.operand
                and input_state.s
                sta simulated_state.a
                sta simulated_state.x
                sta simulated_state.s

                ; Looks like P is inconsistent on my Beeb???
                lda output_state.p
                sta simulated_state.p

                .simulate_y
                .simulate_operand
                rts

;-------------------------------------------------------------------------

print_states: .proc
                ldx #input_state
                lda #'I'
                jsr print_state

                ldx #output_state
                lda #'o'
                jsr print_state

                ldx #simulated_state
                lda #'s'
                jsr print_state

                rts

print_state:
                jsr oswrch

                lda #':'
                jsr oswrch
                
                lda State.operand,x
                ldy #'O'
                jsr reg
                
                lda State.a,x
                ldy #'A'
                jsr reg

                lda State.x,x
                ldy #'X'
                jsr reg

                lda State.y,x
                ldy #'Y'
                jsr reg

                lda State.s,x
                ldy #'S'
                jsr reg

                lda #' '
                jsr oswrch

                lda State.p,x
                ldy #7
-
                asl a
                pha
                lda p_bits,y
                bcs +
                ora #$20
+
                jsr oswrch
                pla
                dey
                bpl -

                jsr osnewl

                bit $ff
                bmi all_tests_done

                rts

reg:
                pha
                lda #' '
                jsr oswrch
                tya
                jsr oswrch
                lda #'='
                jsr oswrch
                pla
                jmp print_hex
                

p_bits: .text 'CZIDBUVN'
                .endproc
                
;-------------------------------------------------------------------------

print0: .proc
                pla
                sta print_ptr+0
                pla
                sta print_ptr+1

loop:
                ldx #print_ptr
                jsr incz16
                
                lda #218        ;items in VDU queue (AUG p221)
                jsr osbyte_x00_yff
                
                ldy #0
                lda (print_ptr),y

                cpx #0
                bne print

                cmp #0
                beq done

print:
                jsr oswrch

                
                jmp loop

done:
                ldx #print_ptr
                jsr incz16
                jmp (print_ptr)
                
                .endproc   

;-------------------------------------------------------------------------

incz16:
                inc 0,x
                bne +
                inc 1,x
+
                rts
                
;-------------------------------------------------------------------------

osbyte_x00_yff:
                ldx #$00
                ldy #$ff
                jmp osbyte
                
;-------------------------------------------------------------------------

get_hi_nybble_ascii:
                lsr a
                lsr a
                lsr a
                lsr a
get_lo_nybble_ascii:
                and #$0f
                sed
                clc
                adc #$90
                adc #$40
                cld
                rts

print_hex:
                pha
                pha
                jsr get_hi_nybble_ascii
                jsr oswrch
                pla
                jsr get_lo_nybble_ascii
                jsr oswrch
                pla
                rts
                
;-------------------------------------------------------------------------
                
                .endsection code
                